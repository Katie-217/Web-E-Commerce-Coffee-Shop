const express = require('express');
const mongoose = require('mongoose');
const { Types } = mongoose;
const Order = require('../models/Order');
const Customer = require('../models/Customer');
const {
  calculatePointsEarned,
  calculateDiscountFromPoints,
  validatePointsUsage
} = require('../utils/loyalty');

const router = express.Router();
const mailer = require("../config/mailer");
const DiscountCode = require("../models/DiscountCode"); 


function formatVnd(amount) {
  try {
    return new Intl.NumberFormat("vi-VN", {
      style: "currency",
      currency: "VND",
      maximumFractionDigits: 0,
    }).format(amount || 0);
  } catch (e) {
    return `${amount} VND`;
  }
}

async function sendOrderConfirmationEmail(order) {
  console.log("[order/email] DEBUG order:", {
    hasOrder: !!order,
    customerEmail: order?.customerEmail,
    id: order?._id || order?.id,
    items: Array.isArray(order?.items) ? order.items.length : 0,
  });

  if (!order || !order.customerEmail) {
    console.log("[order/email] SKIP: missing order or customerEmail");
    return;
  }

  const appName = process.env.APP_NAME || "Coffee Shop";
  const frontendUrl = process.env.FRONTEND_URL || "http://localhost:3000";

  const from =
    process.env.FROM_EMAIL ||
    process.env.MAIL_FROM ||
    process.env.SMTP_USER ||
    "no-reply@example.com";

  const itemsHtml = (order.items || [])
    .map((it) => {
      const qty = Number(it.quantity || it.qty || 1);
      const price = Number(it.price || 0);
      const lineTotal = qty * price;
      const variant =
        it.variant && it.variant.value ? ` (${it.variant.value})` : "";
      return `
        <tr>
          <td style="padding:4px 8px;">${it.name}${variant}</td>
          <td style="padding:4px 8px;text-align:center;">${qty}</td>
          <td style="padding:4px 8px;text-align:right;">${formatVnd(lineTotal)}</td>
        </tr>
      `;
    })
    .join("");

  const totalAmount =
    Number(order.totalAmount || order.total || 0) +
    Number(order.shippingFee || 0);

  const html = `
    <div style="font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;font-size:14px;line-height:1.6;color:#111827">
      <h2 style="font-size:18px;margin:0 0 8px;">Thank you for your order!</h2>
      <p style="margin:0 0 8px;">We have received your order ${order.displayCode || ""
    } at <strong>${appName}</strong>.</p>
      <p style="margin:0 0 12px;">Here is a summary:</p>
      <table width="100%" cellspacing="0" cellpadding="0" style="border-collapse:collapse;border:1px solid #e5e7eb;">
        <thead>
          <tr style="background:#f9fafb;">
            <th align="left" style="padding:6px 8px;font-size:12px;text-transform:uppercase;color:#6b7280;">Item</th>
            <th align="center" style="padding:6px 8px;font-size:12px;text-transform:uppercase;color:#6b7280;">Qty</th>
            <th align="right" style="padding:6px 8px;font-size:12px;text-transform:uppercase;color:#6b7280;">Total</th>
          </tr>
        </thead>
        <tbody>
          ${itemsHtml}
        </tbody>
      </table>
      <p style="margin:12px 0 4px;text-align:right;">
        <strong>Shipping fee:</strong> ${formatVnd(order.shippingFee || 0)}
      </p>
      <p style="margin:0 0 16px;text-align:right;">
        <strong>Grand total:</strong> ${formatVnd(totalAmount)}
      </p>
      <p style="margin:0 0 16px;">You can view your order details at any time:</p>
      <p style="margin:0 0 16px;">
        <a href="${frontendUrl}/orders${order._id ? "/" + order._id : ""
    }" style="display:inline-block;padding:8px 16px;border-radius:999px;background:#7c3aed;color:#fff;text-decoration:none;font-size:14px;">View order</a>
      </p>
      <p style="font-size:12px;color:#6b7280;margin:0;">This email was sent automatically, please do not reply.</p>
    </div>
  `;

  try {
    const info = await mailer.sendMail({
      from,
      to: order.customerEmail,
      subject: `${appName} ‚Äì Order ${order.displayCode || order._id} confirmation`,
      html,
      text: `Thank you for your order at ${appName}. Total: ${formatVnd(
        totalAmount
      )}.`,
    });

    console.log(
      "üìß Order confirmation email sent:",
      info && info.messageId,
      "=>",
      order.customerEmail
    );
  } catch (err) {
    console.error("[order/email] sendMail ERROR:", err);
    throw err; // ƒë·ªÉ .catch b√™n ngo√†i b·∫Øt ƒë∆∞·ª£c
  }
}


// GET /api/orders
router.get('/', async (req, res) => {
  try {
    const page = Math.max(parseInt(req.query.page, 10) || 1, 1);
    const limit = Math.min(Math.max(parseInt(req.query.limit, 10) || 20, 1), 100);
    const skip = (page - 1) * limit;
    const { q, status, email, range, startDate, endDate } = req.query;


    const filters = {};
    if (status) filters.status = status;
    // Only apply email filter if there's no search query (q parameter)
    // When searching by ID, we don't want to filter by email
    if (email && (!q || q === '' || String(q).trim() === '')) {
      filters.customerEmail = new RegExp(String(email), 'i');
    }

    // Handle search query - search ONLY in order ID
    // When user types, filter immediately and narrow down results
    // User can search by ID number without "#" - e.g., "1" or "0001" will find "ORD-2024-0001"
    // IMPORTANT: Only search in id field, NOT in customerEmail or any other field
    // UI displays ID as #XXXX (last 4 hex characters), so search should work with both:
    // - Full ID: "ORD-2024-0003"
    // - Display format: "0003" or "#0003" (last 4 characters)
    // When user types "3", prioritize orders with ID starting with "3" in the numeric part
    // Format: ORD-YYYY-NNNN, so "3" should match orders like ORD-2024-0003, ORD-2024-0030, ORD-2024-0300, ORD-2024-3000
    if (q !== undefined && q !== null && String(q).trim() !== '') {
      let searchTerm = String(q).trim();
      // Remove "#" if user typed it - allow searching without "#"
      searchTerm = searchTerm.replace(/^#+/, '');

      if (searchTerm) {
        // Escape special regex characters to prevent regex injection
        const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        // Search in displayCode field - 4-character alphanumeric code (e.g., "A3f2", "75a0")
        // UI displays ID as #XXXX where XXXX is the displayCode (used to hide real order ID)
        // When user types "A3", match displayCodes STARTING with "A3": "A3f2", "A3bc", etc.
        // When user types "75a", match displayCodes STARTING with "75a": "75a0", "75a1", etc.
        // Pattern: ^[searchTerm] matches displayCodes that start with the search term (case-insensitive)
        // Only search orders that have displayCode (not null/undefined)
        filters.displayCode = {
          $exists: true,
          $ne: null,
          $regex: `^${escapedTerm}`,
          $options: 'i'
        };
      }
    }

    // Time range filtering
    const now = new Date();
    let rangeStart = null;
    let rangeEnd = null;
    const normalizeStart = (d) => (d ? new Date(d) : null);
    const normalizeEnd = (d) => {
      if (!d) return null;
      const e = new Date(d);
      e.setHours(23, 59, 59, 999);
      return e;
    };
    if (range && typeof range === 'string') {
      const r = range.toLowerCase();
      const startOfDay = (d) => {
        const x = new Date(d);
        x.setHours(0, 0, 0, 0);
        return x;
      };
      const startOfWeek = (d) => {
        const x = startOfDay(d);
        const day = x.getDay();
        const diff = (day + 6) % 7;
        x.setDate(x.getDate() - diff);
        return x;
      };
      const startOfMonth = (d) => new Date(d.getFullYear(), d.getMonth(), 1);

      if (r === 'today') {
        rangeStart = startOfDay(now);
        rangeEnd = normalizeEnd(now);
      } else if (r === 'yesterday') {
        const y = new Date(now);
        y.setDate(y.getDate() - 1);
        rangeStart = startOfDay(y);
        rangeEnd = normalizeEnd(y);
      } else if (r === 'week') {
        rangeStart = startOfWeek(now);
        rangeEnd = normalizeEnd(now);
      } else if (r === 'month') {
        rangeStart = startOfMonth(now);
        rangeEnd = normalizeEnd(now);
      } else if (r === 'custom') {
        rangeStart = normalizeStart(startDate);
        rangeEnd = normalizeEnd(endDate || startDate);
      }
    }
    if (rangeStart || rangeEnd) {
      filters.createdAt = {};
      if (rangeStart) filters.createdAt.$gte = rangeStart;
      if (rangeEnd) filters.createdAt.$lte = rangeEnd;
    }


    // Determine sort order: if searching, sort by displayCode (alphabetical order), otherwise by createdAt
    // When searching, we want to prioritize orders where the search term appears at the beginning of displayCode
    let sortOrder = { createdAt: -1 }; // Default: newest first
    if (q !== undefined && q !== null && String(q).trim() !== '') {
      // When searching, sort by displayCode to show results in order
      // This will naturally show orders with the search term at the beginning first
      // (e.g., "3" will show "3abc", "a3bc", "ab3c", "abc3" in order)
      // When user types "a3", it will show: "a3bc", "a3cd", etc.
      sortOrder = { displayCode: 1 }; // Sort by displayCode ascending (alphabetical order)
    }

    // Try different databases: 'orders' database first, then 'CoffeeDB'
    // When searching, try all databases to find matching orders
    let items = [];
    let total = 0;

    // Try 1: 'orders' database > 'ordersList' collection
    try {
      const ordersDb = mongoose.connection.useDb('orders', { useCache: true });
      const coll = ordersDb.collection('ordersList');
      [items, total] = await Promise.all([
        coll.find(filters).sort(sortOrder).skip(skip).limit(limit).toArray(),
        coll.countDocuments(filters)
      ]);
    } catch (err) {
      console.error("Error querying 'orders' database:", err);
    }

    // Try 2: Current database (CoffeeDB) > ordersList collection
    // Always try next database if no results yet (even with search query)
    if (total === 0) {
      try {
        const coll = mongoose.connection.db.collection('ordersList');
        [items, total] = await Promise.all([
          coll.find(filters).sort(sortOrder).skip(skip).limit(limit).toArray(),
          coll.countDocuments(filters)
        ]);
      } catch (err) {
        console.error("Error querying current database ordersList:", err);
      }
    }

    // Fallback to default Order model collection
    // Always try fallback if no results yet (even with search query)
    if (total === 0) {
      try {
        [items, total] = await Promise.all([
          Order.find(filters).sort(sortOrder).skip(skip).limit(limit).lean(),
          Order.countDocuments(filters)
        ]);
      } catch (err) {
        console.error("Error querying default Order model:", err);
      }
    }

    const transformed = items.map(o => ({
      _id: o._id ? String(o._id) : undefined,
      // IMPORTANT: Use o.id (order ID like "ORD-2025-0093") first, fallback to _id only if id doesn't exist
      id: String(o.id || o._id || ''),
      displayCode: (o.displayCode && typeof o.displayCode === 'string' && o.displayCode.trim().length > 0) ? String(o.displayCode).trim() : null, // 4-character alphanumeric code for display
      customerEmail: o.customerEmail,
      customerName: o.customerName,
      total: o.total,
      subtotal: o.subtotal,
      discount: o.discount,
      pointsUsed: o.pointsUsed || 0,
      pointsEarned: o.pointsEarned || 0,
      shippingFee: o.shippingFee,
      currency: o.currency || 'VND',
      status: o.status || 'created',
      paymentStatus: o.paymentStatus || 'pending',
      paymentMethod: o.paymentMethod,
      createdAt: o.createdAt,
      updatedAt: o.updatedAt,
      ...(req.query && String(req.query.includeItems).toLowerCase() === 'true' ? { items: o.items || [] } : {}),
    }));

    res.json({ success: true, data: transformed, items: transformed, pagination: { page, limit, total, totalPages: Math.ceil(total / limit) } });
  } catch (err) {
    res.status(500).json({ success: false, message: 'Failed to fetch orders', error: err.message });
  }
});

// POST /api/orders - t·∫°o ƒë∆°n h√†ng m·ªõi t·ª´ trang checkout
router.post("/", async (req, res) => {
  try {
    const body = req.body || {};
    const rawItems = Array.isArray(body.items) ? body.items : [];

// Chu·∫©n h√≥a items: lu√¥n c√≥ qty & quantity + gi·ªØ l·∫°i variant
const items = rawItems.map((it) => {
  const qty = Number(it.qty ?? it.quantity ?? 1);

  const variant =
    it.variant ??
    it.selectedVariant ??
    it.variants ??
    null; // tu·ª≥ FE g·ª≠i g√¨, gi·ªØ nguy√™n object/string

  return {
    productId: it.productId,
    name: it.name,
    sku: it.sku,
    price: Number(it.price) || 0,
    qty,
    quantity: qty,
    variant, // üëà l∆∞u v√†o order lu√¥n
  };
});


    if (!items.length) {
      return res.status(400).json({
        success: false,
        message: "Order items required",
      });
    }

    // T√≠nh subtotal t·ª´ items
    const subtotal = items.reduce((sum, it) => {
      const price = Number(it.price) || 0;
      const qty = Number(it.quantity || it.qty || 1);
      return sum + price * qty;
    }, 0);

    // Ph√≠ ship: ∆∞u ti√™n FE g·ª≠i, kh√¥ng c√≥ th√¨ auto
    const shippingFee =
      body.shippingFee != null
        ? Number(body.shippingFee)
        : subtotal > 300000
          ? 0
          : 30000;

    // ====== LOYALTY: d√πng ƒëi·ªÉm tr√™n ƒë∆°n n√†y ======

    // L·∫•y email t·ª´ body ho·∫∑c t·ª´ user ƒëƒÉng nh·∫≠p (ƒë·ªÉ t√¨m ƒëi·ªÉm hi·ªán c√≥)
    const customerEmail =
      body.customerEmail ||
      (req.user && (req.user.email || req.user.username)) ||
      null;

    if (!customerEmail) {
      return res.status(400).json({
        success: false,
        message: "customerEmail is required",
      });
    }

    let availablePoints = 0;
    let customerDoc = null;

    try {
      // n·∫øu b·∫°n l∆∞u customer ·ªü DB kh√°c th√¨ ch·ªânh ƒëo·∫°n n√†y
      customerDoc = await Customer.findOne({
        email: customerEmail.toLowerCase().trim(),
      }).lean();

      if (customerDoc && customerDoc.loyalty) {
        availablePoints =
          customerDoc.loyalty.currentPoints ||
          customerDoc.loyalty.points ||
          0;
      }
    } catch (err) {
      console.error("[orders] fetch customer for loyalty failed:", err);
    }

        // S·ªë ƒëi·ªÉm FE g·ª≠i l√™n mu·ªën d√πng cho ƒë∆°n n√†y
    const requestedPoints = Number(body.pointsUsed) || 0;
    let pointsUsed = 0;
    let discountFromPoints = 0;

    if (requestedPoints > 0 && availablePoints > 0) {
      const { ok, pointsToUse, discount } = validatePointsUsage({
        availablePoints,
        pointsToUse: requestedPoints,
        orderTotal: subtotal + shippingFee, // t√≠nh tr√™n t·ªïng tr∆∞·ªõc gi·∫£m
      });

      if (ok) {
        pointsUsed = pointsToUse;
        discountFromPoints = discount; // VND
      }
    }

        // ===== VOUCHER / DISCOUNT CODE =====
    let manualDiscount = 0;
    let appliedDiscountCode = null;

    const rawCode = body.discountCode || body.voucherCode || body.coupon;
    if (rawCode) {
      const normalizedCode = String(rawCode).trim().toUpperCase();

      const codeRegex = /^[A-Z0-9]{5}$/;
      if (!codeRegex.test(normalizedCode)) {
        return res.status(400).json({
          success: false,
          message: "Invalid discount code format.",
        });
      }

      const voucher = await DiscountCode.findOne({ code: normalizedCode });

      if (
        !voucher ||
        voucher.isActive === false ||
        voucher.usedCount >= voucher.maxUses
      ) {
        return res.status(400).json({
          success: false,
          message:
            "This discount code is invalid or has reached its usage limit.",
        });
      }

      const base = subtotal + shippingFee; // t·ªïng tr∆∞·ªõc loyalty

      // üëá H·ªñ TR·ª¢ 2 KI·ªÇU: percent & amount
      if (voucher.type === "amount") {
        // Tr·ª´ th·∫≥ng ti·ªÅn, nh∆∞ng kh√¥ng v∆∞·ª£t qu√° t·ªïng base
        manualDiscount = Math.min(
          Number(voucher.discountAmount || 0),
          base
        );
      } else {
        // M·∫∑c ƒë·ªãnh / "percent"
        const percent =
          typeof voucher.discountPercent === "number"
            ? voucher.discountPercent
            : 10;

        manualDiscount = Math.floor((base * percent) / 100);
      }

      appliedDiscountCode = normalizedCode;

      // tƒÉng s·ªë l·∫ßn d√πng
      voucher.usedCount = (voucher.usedCount || 0) + 1;
      await voucher.save();
    } else {
      // fallback: n·∫øu mu·ªën cho ph√©p g·ª≠i th·∫≥ng discount VND t·ª´ FE
      manualDiscount = Number(body.discount) || 0;
    }


    // T·ªïng discount = voucher + loyalty
    const discount = manualDiscount + discountFromPoints;

    // Total kh√¥ng cho √¢m
    const total = Math.max(0, subtotal + shippingFee - discount);

    const now = new Date();
    const year = now.getFullYear();

    // L·∫•y s·ªë th·ª© t·ª± theo nƒÉm: ORD-YYYY-0001
    let seq = 1;
    try {
      const last = await Order.find({ id: new RegExp(`^ORD-${year}-`) })
        .sort({ createdAt: -1 })
        .limit(1);

      if (last[0] && last[0].id) {
        const m = String(last[0].id).match(/ORD-\d{4}-(\d+)/);
        if (m) seq = parseInt(m[1], 10) + 1;
      }
    } catch (e) {
      console.error("Find last order error:", e);
    }

    const seqStr = String(seq).padStart(4, "0");
    const id = `ORD-${year}-${seqStr}`;

    // M√£ ng·∫Øn hi·ªÉn th·ªã #xxxx
    const displayCode =
      body.displayCode ||
      Math.random().toString(16).slice(2, 6).toLowerCase();

    const customerId =
      body.customerId ||
      (req.user && (req.user.id || req.user._id)) ||
      undefined;

    // Tr·∫°ng th√°i order/payout theo schema
    const VALID_STATUS = [
      "pending",
      "processing",
      "shipped",
      "delivered",
      "cancelled",
      "returned",
    ];
    const VALID_PAYMENT_STATUS = ["pending", "paid", "failed", "refunded"];

    const status = VALID_STATUS.includes(body.status)
      ? body.status
      : "pending";

    const paymentStatus = VALID_PAYMENT_STATUS.includes(body.paymentStatus)
      ? body.paymentStatus
      : "pending";

    const orderDoc = {
      id,
      displayCode,
      items,
      customerEmail,
      customerId,
      customerName: body.customerName,
      customerPhone: body.customerPhone,
      shippingAddress: body.shippingAddress,
      billingAddress: body.billingAddress || body.shippingAddress,
      subtotal,
      shippingFee,
      discount,
      discountCode: appliedDiscountCode || null,
      tax: body.tax || 0,
      total,
      currency: body.currency || "VND",
      notes: body.note,
      paymentMethod: body.paymentMethod || "cod",
      paymentStatus,
      status,
      shippingActivity: body.shippingActivity || [],
      pointsUsed,       // ‚≠ê l∆∞u l·∫°i ƒëi·ªÉm ƒë√£ d√πng
      pointsEarned: 0,  // s·∫Ω set khi delivered ·ªü PATCH
    };

    // t·∫°o ƒë∆°n
    const order = await Order.create(orderDoc);

    // N·∫øu c√≥ d√πng ƒëi·ªÉm th√¨ tr·ª´ ƒëi·ªÉm c·ªßa kh√°ch
    if (pointsUsed > 0 && customerDoc) {
      try {
        const customerId = customerDoc._id || customerDoc.id;
        const historyEntry = {
          orderId: order.id,
          orderDate: order.createdAt || new Date(),
          type: 'used',
          points: pointsUsed,
          description: `Used ${pointsUsed} points for order ${order.id}`,
          createdAt: new Date(),
        };

        await Customer.findByIdAndUpdate(customerId, {
          $inc: { 'loyalty.currentPoints': -pointsUsed },
          $push: { 'loyalty.history': historyEntry },
        });
      } catch (err) {
        console.error("[orders] deduct loyalty points failed:", err);
      }
    }


    // üîî G·ª¨I EMAIL X√ÅC NH·∫¨N ƒê∆†N H√ÄNG (kh√¥ng ch·∫∑n response n·∫øu l·ªói)
    sendOrderConfirmationEmail(order).catch((err) => {
      console.error("[orders] sendOrderConfirmationEmail failed:", err);
    });

    const transformed = {
      _id: String(order._id),
      id: order.id,
      displayCode: order.displayCode || null,
      customerEmail: order.customerEmail,
      customerId: order.customerId,
      customerName: order.customerName,
      customerPhone: order.customerPhone,
      items: order.items,
      subtotal: order.subtotal,
      shippingFee: order.shippingFee,
      discount: order.discount,
      tax: order.tax,
      total: order.total,
      currency: order.currency,
      status: order.status,
      paymentMethod: order.paymentMethod,
      paymentStatus: order.paymentStatus,
      shippingAddress: order.shippingAddress,
      billingAddress: order.billingAddress,
      shippingActivity: order.shippingActivity,
      pointsUsed: order.pointsUsed || 0,
      pointsEarned: order.pointsEarned || 0,
      createdAt: order.createdAt,
      updatedAt: order.updatedAt,
    };

    return res.status(201).json({ success: true, data: transformed });
  } catch (err) {
    console.error("Create order error:", err);
    return res.status(500).json({
      success: false,
      message: "Failed to create order",
      error: err.message,
    });
  }
});

// GET /api/orders/:id
router.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    let order = null;

    // Try collections in order: orders DB > ordersList, then current DB > ordersList, orders.ordersList, orders
    // Try 1: 'orders' database > 'ordersList' collection
    try {
      const ordersDb = mongoose.connection.useDb('orders', { useCache: true });
      const coll = ordersDb.collection('ordersList');

      if (Types.ObjectId.isValid(id)) {
        const objId = new Types.ObjectId(id);
        order = await coll.findOne({ _id: objId });
      }
      if (!order) {
        order = await coll.findOne({ id: id });
      }
      if (!order) {
        // Also try with _id as string
        order = await coll.findOne({ _id: id });
      }
      if (!order && !isNaN(id)) {
        order = await coll.findOne({ id: String(id) });
      }
    } catch (err) {
    }

    // Try 2: Current database > ordersList collection
    if (!order) {
      try {
        const coll = mongoose.connection.db.collection('ordersList');
        if (Types.ObjectId.isValid(id)) {
          order = await coll.findOne({ _id: new Types.ObjectId(id) });
        }
        if (!order) {
          order = await coll.findOne({ id });
        }
        if (!order && !isNaN(id)) {
          order = await coll.findOne({ id: String(id) });
        }
      } catch (err) {
      }
    }

    // Try 3: orders.ordersList
    if (!order) {
      try {
        const coll = mongoose.connection.db.collection('orders.ordersList');
        if (Types.ObjectId.isValid(id)) {
          order = await coll.findOne({ _id: new Types.ObjectId(id) });
        }
        if (!order) {
          order = await coll.findOne({ id });
        }
        if (!order && !isNaN(id)) {
          order = await coll.findOne({ id: String(id) });
        }
      } catch (err) {
      }
    }

    // Try 3: orders
    if (!order) {
      try {
        const coll = mongoose.connection.db.collection('orders');
        if (Types.ObjectId.isValid(id)) {
          order = await coll.findOne({ _id: new Types.ObjectId(id) });
        }
        if (!order) {
          order = await coll.findOne({ id });
        }
        if (!order && !isNaN(id)) {
          order = await coll.findOne({ id: String(id) });
        }
      } catch (err) {
      }
    }

    // Fallback to default Order model collection
    if (!order) {
      if (Types.ObjectId.isValid(id)) order = await Order.findById(id);
      if (!order) order = await Order.findOne({ id });
      if (!order && !isNaN(id)) order = await Order.findOne({ id: String(id) });
    }
    if (!order) return res.status(404).json({ success: false, message: 'Order not found' });
    const o = order.toObject ? order.toObject() : order;
    const transformed = {
      _id: o._id ? String(o._id) : undefined,
      id: String(o._id || o.id || ''),
      displayCode: o.displayCode || null, // Random 4-character hex code for display
      customerEmail: o.customerEmail,
      customerId: o.customerId,
      customerName: o.customerName,
      customerPhone: o.customerPhone,
      items: o.items || [],
      subtotal: o.subtotal,
      shippingFee: o.shippingFee,
      discount: o.discount,
      pointsUsed: o.pointsUsed || 0,
      pointsEarned: o.pointsEarned || 0,
      tax: o.tax,
      total: o.total,
      currency: o.currency || 'VND',
      status: o.status || 'created',
      paymentMethod: o.paymentMethod,
      paymentStatus: o.paymentStatus,
      shippingAddress: o.shippingAddress,
      billingAddress: o.billingAddress,
      shippingActivity: o.shippingActivity || [],
      createdAt: o.createdAt,
      updatedAt: o.updatedAt,
    };
    res.json({ success: true, data: transformed });
  } catch (err) {
    res.status(500).json({ success: false, message: 'Failed to fetch order', error: err.message });
  }
});

// Helper: update ƒëi·ªÉm loyalty khi ƒë∆°n ho√†n t·∫•t
// - COD: khi status = 'delivered'
// - Online: khi paymentStatus = 'paid'
async function updateCustomerLoyaltyPoints(order) {
  try {
    if (!order) return;

    const method = (order.paymentMethod || "").toLowerCase();
    const isCod =
      method === "cod" ||
      method === "cash_on_delivery" ||
      method === "cod_cash";

    // COD: ch·ªâ c·ªông khi ƒë√£ giao xong (coi nh∆∞ ƒë√£ thu ti·ªÅn)
    if (isCod) {
      if (order.status !== "delivered") return;
    } else {
      // Online: ch·ªâ c·ªông khi ƒë√£ thanh to√°n
      if (order.paymentStatus !== "paid") return;
    }

    const customerEmail = order.customerEmail?.toLowerCase()?.trim();
    if (!customerEmail) return;

    // üîç Lu√¥n t√¨m b·∫±ng model Customer (ƒë√¢y l√† n∆°i auth + loyalty ƒëang d√πng)
    const customer = await Customer.findOne({ email: customerEmail });
    if (!customer) {
      console.warn(`[loyalty] Customer not found for email: ${customerEmail}`);
      return;
    }

    // T√≠nh ti·ªÅn th·ª±c tr·∫£ = subtotal + ship - discount
    const gross = (order.subtotal || 0) + (order.shippingFee || 0);
    const discount = order.discount || 0; // g·ªìm voucher + d√πng ƒëi·ªÉm
    const orderTotal = Math.max(0, gross - discount);

    const pointsEarned = calculatePointsEarned(orderTotal);
    if (pointsEarned <= 0) return;

    const currentPoints =
      (customer.loyalty &&
        (customer.loyalty.currentPoints ?? customer.loyalty.points)) ||
      0;

    const totalEarned =
      (customer.loyalty && customer.loyalty.totalEarned) || 0;

    const newPoints = currentPoints + pointsEarned;
    const newTotalEarned = totalEarned + pointsEarned;

    const orderIdStr = order.id || order._id?.toString();

    const historyEntry = {
      orderId: orderIdStr,
      orderDate: order.createdAt || new Date(),
      type: "earned",
      points: pointsEarned,
      description: `Earned ${pointsEarned} points from order ${orderIdStr}`,
      createdAt: new Date(),
    };

    const setData = {
      "loyalty.totalEarned": newTotalEarned,
      "loyalty.currentPoints": newPoints,
      "loyalty.lastAccrualAt": new Date(),
    };

    // ‚úÖ C·∫≠p nh·∫≠t tr·ª±c ti·∫øp v√†o Customer (c√πng n∆°i auth/me ƒë·ªçc)
    await Customer.findByIdAndUpdate(customer._id, {
      $set: setData,
      $push: { "loyalty.history": historyEntry },
    });
  } catch (err) {
    console.error("Error in updateCustomerLoyaltyPoints:", err);
  }
}

// PATCH /api/orders/:id - Update order status and/or shipping activity
router.patch('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { status, paymentStatus, shippingActivity, pointsUsed } = req.body;


    // Get current order to check previous status
    let currentOrder = null;

    // Try 1: 'orders' database > ordersList collection
    try {
      const ordersDb = mongoose.connection.useDb('orders', { useCache: true });
      const coll = ordersDb.collection('ordersList');

      if (Types.ObjectId.isValid(id)) {
        const objId = new Types.ObjectId(id);
        currentOrder = await coll.findOne({ _id: objId });
      }
      if (!currentOrder) {
        currentOrder = await coll.findOne({ id });
      }
      if (!currentOrder && !isNaN(id)) {
        currentOrder = await coll.findOne({ id: String(id) });
      }
    } catch (err) {
      // ignore
    }

    // Try 2: current database > ordersList collection
    if (!currentOrder) {
      try {
        const coll = mongoose.connection.db.collection('ordersList');

        if (Types.ObjectId.isValid(id)) {
          currentOrder = await coll.findOne({ _id: new Types.ObjectId(id) });
        }
        if (!currentOrder) {
          currentOrder = await coll.findOne({ id });
        }
        if (!currentOrder && !isNaN(id)) {
          currentOrder = await coll.findOne({ id: String(id) });
        }
      } catch (err) {
        // ignore
      }
    }

    // Try 3: orders.ordersList
    if (!currentOrder) {
      try {
        const coll = mongoose.connection.db.collection('orders.ordersList');

        if (Types.ObjectId.isValid(id)) {
          currentOrder = await coll.findOne({ _id: new Types.ObjectId(id) });
        }
        if (!currentOrder) {
          currentOrder = await coll.findOne({ id });
        }
        if (!currentOrder && !isNaN(id)) {
          currentOrder = await coll.findOne({ id: String(id) });
        }
      } catch (err) {
        // ignore
      }
    }

    // Try 4: orders
    if (!currentOrder) {
      try {
        const coll = mongoose.connection.db.collection('orders');

        if (Types.ObjectId.isValid(id)) {
          currentOrder = await coll.findOne({ _id: new Types.ObjectId(id) });
        }
        if (!currentOrder) {
          currentOrder = await coll.findOne({ id });
        }
        if (!currentOrder && !isNaN(id)) {
          currentOrder = await coll.findOne({ id: String(id) });
        }
      } catch (err) {
        // ignore
      }
    }

    // Fallback to default Order model collection
    if (!currentOrder) {
      if (Types.ObjectId.isValid(id)) {
        currentOrder = await Order.findById(id);
      }
      if (!currentOrder) {
        currentOrder = await Order.findOne({ id });
      }
      if (!currentOrder && !isNaN(id)) {
        currentOrder = await Order.findOne({ id: String(id) });
      }
    }

    // ---------- QUY·∫æT ƒê·ªäNH KHI N√ÄO C·ªòNG ƒêI·ªÇM ----------
    let shouldUpdatePoints = false;


    // Build update data
    const updateData = {};
    if (status !== undefined) updateData.status = status;
    if (paymentStatus !== undefined) updateData.paymentStatus = paymentStatus;
    if (shippingActivity !== undefined) updateData.shippingActivity = shippingActivity;
    if (pointsUsed !== undefined) {
      updateData.pointsUsed = Math.max(0, parseInt(pointsUsed, 10) || 0);
      // Calculate discount from points used (1 point = 1,000 VND)
      updateData.discount = calculateDiscountFromPoints(updateData.pointsUsed);

      // Recalculate total if discount changed
      if (currentOrder) {
        const subtotal = currentOrder.subtotal || 0;
        const shippingFee = currentOrder.shippingFee || 0;
        updateData.total = Math.max(0, subtotal + shippingFee - updateData.discount);
      }
    }

    // ---------- T√çNH ƒêI·ªÇM T√çCH (COD vs Online) ----------
    if (currentOrder) {
      const method = (currentOrder.paymentMethod || "").toLowerCase();
      const isCod =
        method === "cod" ||
        method === "cash_on_delivery" ||
        method === "cod_cash";

      // Tr·∫°ng th√°i m·ªõi sau update (n·∫øu kh√¥ng g·ª≠i th√¨ d√πng gi√° tr·ªã c≈©)
      const newStatus =
        status !== undefined ? status : currentOrder.status;
      const newPaymentStatus =
        paymentStatus !== undefined
          ? paymentStatus
          : currentOrder.paymentStatus;

      if (isCod) {
        // COD: l·∫ßn ƒë·∫ßu chuy·ªÉn sang delivered th√¨ c·ªông ƒëi·ªÉm
        if (
          newStatus === "delivered" &&
          currentOrder.status !== "delivered"
        ) {
          shouldUpdatePoints = true;
        }
      } else {
        // Online: l·∫ßn ƒë·∫ßu chuy·ªÉn sang paid th√¨ c·ªông ƒëi·ªÉm
        if (
          newPaymentStatus === "paid" &&
          currentOrder.paymentStatus !== "paid"
        ) {
          shouldUpdatePoints = true;
        }
      }

      if (shouldUpdatePoints) {
        const gross =
          (currentOrder.subtotal || 0) +
          (currentOrder.shippingFee || 0);

        // N·∫øu trong PATCH n√†y c√≥ ƒë·ªïi pointsUsed/discount th√¨ ∆∞u ti√™n discount m·ªõi
        const discount =
          updateData.discount !== undefined
            ? updateData.discount
            : (currentOrder.discount || 0);

        const orderTotal = Math.max(0, gross - discount); // ti·ªÅn th·ª±c tr·∫£ sau gi·∫£m

        updateData.pointsEarned = calculatePointsEarned(orderTotal);
      }

    }

    updateData.updatedAt = new Date();







    updateData.updatedAt = new Date();

    if (Object.keys(updateData).length === 0) {
      return res.status(400).json({ success: false, message: 'No fields to update' });
    }

    // Use same logic as GET route to find order
    // Try collections in order: orders DB > ordersList, then current DB > ordersList, orders.ordersList, orders
    let updated = false;

    // Try 1: 'orders' database > 'ordersList' collection
    try {
      const ordersDb = mongoose.connection.useDb('orders', { useCache: true });
      const coll = ordersDb.collection('ordersList');

      let result = null;

      if (Types.ObjectId.isValid(id)) {
        const objId = new Types.ObjectId(id);
        result = await coll.updateOne(
          { _id: objId },
          { $set: updateData }
        );
        if (result.matchedCount > 0) {
          updated = true;
        }
      }

      if (!updated) {
        result = await coll.updateOne(
          { id: id },
          { $set: updateData }
        );
        if (result.matchedCount > 0) {
          updated = true;
        }
      }

      if (!updated) {
        // Also try with _id as string
        result = await coll.updateOne(
          { _id: id },
          { $set: updateData }
        );
        if (result.matchedCount > 0) {
          updated = true;
        }
      }

      if (!updated && !isNaN(id)) {
        result = await coll.updateOne(
          { id: String(id) },
          { $set: updateData }
        );
        if (result.matchedCount > 0) {
          updated = true;
        }
      }
    } catch (err) {
    }

    // Try 2: Current database > ordersList collection
    if (!updated) {
      try {
        const coll = mongoose.connection.db.collection('ordersList');
        let result = null;

        if (Types.ObjectId.isValid(id)) {
          result = await coll.updateOne(
            { _id: new Types.ObjectId(id) },
            { $set: updateData }
          );
          if (result.matchedCount > 0) {
            updated = true;
          }
        }

        if (!updated) {
          result = await coll.updateOne(
            { id },
            { $set: updateData }
          );
          if (result.matchedCount > 0) {
            updated = true;
          }
        }

        if (!updated && !isNaN(id)) {
          result = await coll.updateOne(
            { id: String(id) },
            { $set: updateData }
          );
          if (result.matchedCount > 0) {
            updated = true;
          }
        }
      } catch (err) {
      }
    }

    // Try 3: orders.ordersList
    if (!updated) {
      try {
        const coll = mongoose.connection.db.collection('orders.ordersList');
        let result = null;

        if (Types.ObjectId.isValid(id)) {
          result = await coll.updateOne(
            { _id: new Types.ObjectId(id) },
            { $set: updateData }
          );
          if (result.matchedCount > 0) {
            updated = true;
          }
        }

        if (!updated) {
          result = await coll.updateOne(
            { id },
            { $set: updateData }
          );
          if (result.matchedCount > 0) {
            updated = true;
          }
        }

        if (!updated && !isNaN(id)) {
          result = await coll.updateOne(
            { id: String(id) },
            { $set: updateData }
          );
          if (result.matchedCount > 0) {
            updated = true;
          }
        }
      } catch (err) {
      }
    }

    // Try 4: orders
    if (!updated) {
      try {
        const coll = mongoose.connection.db.collection('orders');
        let result = null;

        if (Types.ObjectId.isValid(id)) {
          result = await coll.updateOne(
            { _id: new Types.ObjectId(id) },
            { $set: updateData }
          );
          if (result.matchedCount > 0) {
            updated = true;
          }
        }

        if (!updated) {
          result = await coll.updateOne(
            { id },
            { $set: updateData }
          );
          if (result.matchedCount > 0) {
            updated = true;
          }
        }

        if (!updated && !isNaN(id)) {
          result = await coll.updateOne(
            { id: String(id) },
            { $set: updateData }
          );
          if (result.matchedCount > 0) {
            updated = true;
          }
        }
      } catch (err) {
      }
    }

    // Fallback to Order model
    if (!updated) {
      if (Types.ObjectId.isValid(id)) {
        const order = await Order.findByIdAndUpdate(id, { $set: updateData }, { new: true });
        if (order) {
          updated = true;
        }
      }
      if (!updated) {
        const order = await Order.findOneAndUpdate({ id }, { $set: updateData }, { new: true });
        if (order) {
          updated = true;
        }
      }
      if (!updated && !isNaN(id)) {
        const order = await Order.findOneAndUpdate({ id: String(id) }, { $set: updateData }, { new: true });
        if (order) {
          updated = true;
        }
      }
    }

    if (!updated) {
      return res.status(404).json({
        success: false,
        message: `Order not found with id: ${id}`
      });
    }

    // ---------- G·ªåI HELPER C·ªòNG ƒêI·ªÇM (COD / Online) ----------
    if (shouldUpdatePoints && currentOrder) {
      // D√πng currentOrder + d·ªØ li·ªáu v·ª´a update, kh√¥ng c·∫ßn ƒë·ªçc l·∫°i DB
      const plainCurrent =
        currentOrder.toObject ? currentOrder.toObject() : currentOrder;

      const mergedOrder = {
        ...plainCurrent,
        ...updateData,
        updatedAt: updateData.updatedAt || new Date(),
      };

      await updateCustomerLoyaltyPoints(mergedOrder);
    }


    // If points were used, deduct from customer
    if (pointsUsed !== undefined && pointsUsed > 0 && currentOrder) {
      const customerEmail = currentOrder.customerEmail?.toLowerCase()?.trim();
      if (customerEmail) {
        try {
          // Find customer
          let customer = null;
          try {
            const customersDb = mongoose.connection.useDb('customers', { useCache: true });
            const customersColl = customersDb.collection('customersList');
            customer = await customersColl.findOne({ email: customerEmail });
          } catch (err) {
            const customersColl = mongoose.connection.db.collection('customersList');
            customer = await customersColl.findOne({ email: customerEmail });
          }

          if (!customer) {
            customer = await Customer.findOne({ email: customerEmail }).lean();
          }

          if (customer) {
            const customerId = customer._id || customer.id;
            const currentPoints = customer.loyalty?.currentPoints || customer.loyalty?.points || 0;
            const newPoints = Math.max(0, currentPoints - pointsUsed);

            // Add to history
            const historyEntry = {
              orderId: currentOrder.id || currentOrder._id?.toString(),
              orderDate: currentOrder.createdAt || new Date(),
              type: 'used',
              points: pointsUsed,
              description: `Used ${pointsUsed} points for order ${currentOrder.id}`,
              createdAt: new Date()
            };

            try {
              const customersDb = mongoose.connection.useDb('customers', { useCache: true });
              const customersColl = customersDb.collection('customersList');
              await customersColl.updateOne(
                { _id: Types.ObjectId.isValid(customerId) ? new Types.ObjectId(customerId) : customerId },
                {
                  $set: { 'loyalty.currentPoints': newPoints },
                  $push: { 'loyalty.history': historyEntry }
                }
              );
            } catch (err) {
              try {
                const customersColl = mongoose.connection.db.collection('customersList');
                await customersColl.updateOne(
                  { _id: Types.ObjectId.isValid(customerId) ? new Types.ObjectId(customerId) : customerId },
                  {
                    $set: { 'loyalty.currentPoints': newPoints },
                    $push: { 'loyalty.history': historyEntry }
                  }
                );
              } catch (err2) {
                await Customer.findByIdAndUpdate(customerId, {
                  $set: { 'loyalty.currentPoints': newPoints },
                  $push: { 'loyalty.history': historyEntry }
                });
              }
            }

          }
        } catch (err) {
          console.error('Error deducting points from customer:', err);
        }
      }
    }

    res.json({ success: true, message: 'Order updated successfully' });
  } catch (err) {
    res.status(500).json({ success: false, message: 'Failed to update order', error: err.message });
  }
});

module.exports = router;
